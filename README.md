# üç∫ Controlador de Temperatura para Produ√ß√£o de Cerveja Artesanal

Um sistema embarcado moderno e modular para monitoramento e controle t√©rmico durante a brassagem de cerveja artesanal, baseado em perfis de temperatura ajust√°veis e l√≥gica de controle robusta.

## √çndice

1. [Vis√£o Geral](#vis√£o-geral)  
2. [Objetivos](#objetivos)  
3. [Tecnologias Utilizadas](#tecnologias-utilizadas)  
4. [Arquitetura do Sistema](#arquitetura-do-sistema)  
5. [Modelagem e L√≥gica de Estados](#modelagem-e-l√≥gica-de-estados)  
6. [C√≥digo e Integra√ß√£o Itemis](#c√≥digo-e-integra√ß√£o-itemis)
7. [Plano de Entregas e Metodologia](#plano-de-entregas-e-metodologia)  
8. [Requisitos do Projeto](#requisitos-do-projeto)  
9.  [Funcionalidades Extras](#funcionalidades-extras)  
10. [Receitas Utilizadas](#receitas-utilizadas)
11. [Resultados e Logs de Processo](#resultados-e-logs-de-processo)
12. [Considera√ß√µes Finais e Melhorias Futuras](#considera√ß√µes-finais-e-melhorias-futuras)
13. [Changelog](#changelog)

---

### Vis√£o Geral

Este projeto tem como objetivo desenvolver um controlador inteligente para automatizar o processo de fabrica√ß√£o de cerveja artesanal. O sistema gerencia a temperatura do mosto e ativa automaticamente um mixer, garantindo homogeneidade t√©rmica e ader√™ncia a curvas de temperatura personaliz√°veis.

Com uma arquitetura flex√≠vel, o sistema pode ser simulado em ambiente de desenvolvimento e implantado em microcontroladores reais, permitindo testes eficientes e facilidade de manuten√ß√£o.

### Objetivos

- **Controle t√©rmico preciso:** Manter o mosto dentro da faixa desejada com controle PID e/ou ON/OFF com histerese.
- **Homogeneiza√ß√£o eficiente:** Acionar o mixer automaticamente conforme a diferen√ßa de temperatura entre sensores.
- **Curvas customiz√°veis:** Permitir defini√ß√£o e carregamento de receitas personalizadas.
- **Seguran√ßa embutida:** Detectar falhas e fornecer alertas visuais/sonoros.
- **Interface acess√≠vel:** Oferecer informa√ß√µes em tempo real via display e comunica√ß√£o serial.
- **Portabilidade e testes:** Simular em PC e transferir facilmente para o ESP32.

---

### Tecnologias Utilizadas

- **Plataforma:** ESP32 (com suporte a FreeRTOS)
- **Linguagem:** C++ com princ√≠pios de orienta√ß√£o a objetos
- **Modelagem de Estados:** itemis CREATE / itemis CREATE
- **Interface com Usu√°rio:**
  - Display OLED ou LCD via I2C
  - Teclado matricial 4x4
  - Comunica√ß√£o UART com PC
- **Sensores:** Temperatura (I2C ou OneWire)
- **Atuadores:** Resist√™ncia (PWM), Mixer (GPIO/PWM)
- **Versionamento:** Git + GitHub
- **Documenta√ß√£o:** Doxygen
- **Testes:** Unity ou Google Test *(em defini√ß√£o)*

---

### Arquitetura do Sistema
O controlador √© baseado em uma arquitetura modular e desacoplada, onde o microcontrolador ESP32 atua como o n√∫cleo de processamento central, executando tarefas paralelas por meio do FreeRTOS, gerenciando sensores, atuadores e a interface com o usu√°rio.

##### Camada de Sensoriamento
- Sensores de Temperatura: DS18B20 (OneWire) ou simulados via I2C entre dois ESP32 (mestre/escravo)
- Dados s√£o capturados periodicamente por tarefas do sistema operacional (RTOS)

##### Camada de Controle
- Controle ON/OFF com Histerese: simples e seguro, usado como fallback
- Controle PID: integrado via biblioteca PID_v1, ajustando o PWM para regular o aquecimento com precis√£o
- O controle atua sobre a resist√™ncia de aquecimento, com sa√≠das moduladas por PWM

##### Camada de Atua√ß√£o
- Mixer: acionado via GPIO com l√≥gica baseada na diferen√ßa entre sensores (Delta T)
- Resist√™ncia: controlada por PWM com duty cycle ajustado pelo controlador
- LEDs: usados para alertas e status de sistema

##### Camada de Interface
- Display OLED: apresenta temperatura atual, setpoint, tempo restante e status do sistema
- Teclado 4x4: entrada de comandos, sele√ß√£o de receitas, navega√ß√£o por menus
- UART: comunica√ß√£o com PC para upload de receitas, logs e visualiza√ß√£o remota

##### Camada de L√≥gica de Estados
- Implementada com itemis CREATE (itemis CREATE), gerando c√≥digo em C++
- Organiza os fluxos de opera√ß√£o: IDLE, MENU, STANDARD_PROCESS, HEATING, RESTING, FINISHED, etc.
- Transi√ß√µes autom√°ticas com base em eventos

##### Abstra√ß√£o de Hardware (HAL)
- Todos os perif√©ricos (sensores, displays, atuadores) s√£o acessados por meio de camadas de abstra√ß√£o, permitindo simula√ß√£o em ambiente de PC
- Essa arquitetura permite alta portabilidade e facilita manuten√ß√£o e testes automatizados

##### Simula√ß√£o Mestre-Escravo
- Sistema alternativo onde o ESP32 "mestre" controla a brassagem e o ESP32 "escravo" simula a resposta t√©rmica do ambiente
- Utiliza modelo de in√©rcia t√©rmica (RC) para testes realistas do controle PID

---

### Modelagem e L√≥gica de Estados

Para garantir previsibilidade e seguran√ßa no controle da brassagem, a l√≥gica do sistema foi inteiramente modelada por meio de uma m√°quina de estados finita, utilizando a ferramenta [itemis CREATE](https://www.itemis.com/en/). Essa modelagem define claramente o fluxo de opera√ß√£o do sistema, suas transi√ß√µes, eventos esperados e comportamentos em cada estado.

Abaixo, apresentamos o diagrama completo da m√°quina de estados desenvolvida para este projeto:

üìå **Estados Principais:** `IDLE`, `MENU`, `STANDARD_PROCESS`, `HEATING`, `RESTING`, `FINISHED`, `EXIT`  ... etc<br>
üîÅ **Eventos de Transi√ß√£o:** `start_button`, `tempOk`, `timeout`, `erroSensor`, `abort` ... etc

![Diagrama da M√°quina de Estados](itemis/statechart.png)
*Modelo visual criado com itemis CREATE.*
*Outros arquivos podemser vistos em ```../itemis/project/```*

Essa modelagem permite a gera√ß√£o autom√°tica de c√≥digo C++, que √© posteriormente integrado ao projeto embarcado. Isso garante consist√™ncia entre o comportamento simulado e a implementa√ß√£o real.

#### Componentes Vis√≠veis na Bancada:
- ESP32 com m√≥dulos GPIO expostos
- Display OLED via I2C
- Teclado matricial 4x4
- Sensor de temperatura (DS18B20)
- LED RGB ou sem√°foro de estado
- Resist√™ncia controlada via PWM
- Cabos de alimenta√ß√£o e conex√µes UART
- ESP32 Mestre-Escravo
- Mixer e Controlador

#### Imagens:

##### Montagem f√≠sica:
![Montagem Completa](media/overview.jpg)
*Vista geral com todos os componentes interligados.*

##### Fritzing:
![Fritzing](media/project-beer_bb.png)
*Vista geral das liga√ß√µes dos componentes interligados no Fritzing.*

##### Detalhe do Display:
![Detalhe do Display e Teclado](media/overview_recipe.jpg)
*Interface de usu√°rio: teclado matricial e display OLED indicando a etapa atual da brassagem.*

#### üé• Demonstra√ß√£o em V√≠deo:
Clique abaixo para ver a opera√ß√£o do sistema em tempo real durante uma simula√ß√£o de brassagem:

[‚ñ∂Ô∏è  YouTube](https://youtu.be/LINK)
**TODO**

---

### C√≥digo e Integra√ß√£o Itemis

A ferramenta itemis CREATE gerou automaticamente os arquivos-fonte para representar a m√°quina de estados, incluindo:

- `Statechart.h`
- `Statechart.cpp`
- `sc_statemachine.h`, `sc_eventdriven.h`, `sc_timer.h`, `sc_types.h`

Esses arquivos foram integrados ao ambiente de desenvolvimento do ESP32, com callbacks definidos em `StatechartCallback.h` para lidar com as a√ß√µes de entrada (`entry`) e transi√ß√µes de estados.

* Os arquivos podem ser visualizados em:

```
../freeRTOS/borraco/src/
```

Toda a l√≥gica de resposta ao usu√°rio, atualiza√ß√£o de display e leitura do teclado √© feita dentro do StatechartCallback, garantindo que o fluxo operacional siga rigorosamente a modelagem definida no itemis CREATE.


* Estrutura de Pastas:

```bash
/src-gen ‚Üí arquivos gerados
/src     ‚Üí l√≥gica de aplica√ß√£o
/include ‚Üí abstra√ß√µes de hardware e callbacks
```

Ao modificar a m√°quina no itemis CREATE e regerar o c√≥digo, o sistema se adapta automaticamente √†s novas transi√ß√µes, preservando a l√≥gica central.

---

### Plano de Entregas e Metodologia
O projeto foi estruturado em tr√™s fases principais de entrega, cada uma com foco progressivo na consolida√ß√£o da solu√ß√£o embarcada. Essa divis√£o visa facilitar o desenvolvimento incremental, permitindo testes cont√≠nuos e valida√ß√£o parcial de funcionalidades antes da integra√ß√£o final.

##### Entrega 1 ‚Äî Funda√ß√£o e Estrutura L√≥gica
Objetiva estabelecer a base do projeto, incluindo a modelagem conceitual, estrutura l√≥gica de controle e primeiros testes de fluxo:

- Levantamento e categoriza√ß√£o de requisitos funcionais e n√£o funcionais
- Defini√ß√£o da curva padr√£o de brassagem a ser utilizada
- Modelagem da m√°quina de estados no itemis CREATE (itemis CREATE)
- Cria√ß√£o do reposit√≥rio GitHub e organiza√ß√£o da base de c√≥digo inicial

##### Entrega 2 ‚Äî Desenvolvimento de Funcionalidades-Chave
Foca na implementa√ß√£o dos principais m√≥dulos de hardware e controle, promovendo a simula√ß√£o completa de um processo de brassagem:

- Integra√ß√£o com sensores de temperatura (reais ou simulados via I2C)
- Controle de aquecimento via ON/OFF com histerese e/ou PID
- Visualiza√ß√£o de dados em display (OLED/LCD)
- Interface com teclado matricial 4x4
- Comunica√ß√£o com PC via UART para logs e comandos
- Implementa√ß√£o da l√≥gica de receitas e controle por etapas

##### Entrega 3 ‚Äî Integra√ß√£o Total e Recursos Avan√ßados
Consolida o sistema com foco em robustez, seguran√ßa, testes e usabilidade:

- Adi√ß√£o de funcionalidades extras: alarme sonoro, sem√°foro LED, logs
- Implementa√ß√£o de detec√ß√£o de falhas (sensores, comunica√ß√£o)
- Gera√ß√£o de documenta√ß√£o automatizada via Doxygen
- Testes finais e simula√ß√£o realista com modelo de in√©rcia t√©rmica
- Apresenta√ß√£o e demonstra√ß√£o funcional completa

---

### Requisitos do Projeto
Os requisitos foram categorizados em Funcionais (o que o sistema deve fazer) e N√£o Funcionais (como o sistema deve funcionar). O progresso de cada requisito √© visualizado atrav√©s de uma barra de status.

| ID | Tipo | Requisito | Prioridade | Progresso | Entrega Relacionada | Observa√ß√µes |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| **RF01**  | **Funcional**   | O sistema deve aplicar algoritmos de controle (PID e/ou ON/OFF com histerese) para manter a temperatura do mosto dentro de uma margem de $\pm 1 ^\circ C$ do *setpoint* definido pela curva de brassagem, acionando as resist√™ncias de aquecimento. | Alta | Conclu√≠do [üü©üü©üü©üü©üü©] 100% | Entrega 2 | O controle PID foi integrado. A fun√ß√£o do controlTask calcula o PID e aplica o Output diretamente ao PWM. |
| **RF02**  | **Funcional** | O sistema deve carregar e executar uma curva de temperatura padr√£o pr√©-configurada (ex: 67¬∞C por X min, 78¬∞C por Y min, 100¬∞C por Z min) ao iniciar a brassagem. | Alta          | Conclu√≠do [üü©üü©üü©üü©üü©] 100% | Entrega 1 | Deixa claro que a curva padr√£o √© a default e como ela √© iniciada. (Receitas definidas e lidas, l√≥gica de etapas implementada). |
| **RF03** | **Funcional** | O sistema deve permitir o *upload* de curvas de temperatura customizadas via interface serial (UART), ou via comandos em tela (KEYPAD 4X4). Cada curva deve conter m√∫ltiplos *steps* definidos por temperatura e dura√ß√£o, e o sistema deve validar a integridade dos dados recebidos. | Alta | Pendente [üü•üü•üü•üü•üü•] 0% | Entrega 2 | Detalha a forma de *upload* e a necessidade de valida√ß√£o. |
| **RF04**  | **Funcional** | O sistema deve ativar automaticamente o *mixer* quando a diferen√ßa de temperatura entre quaisquer dois sensores exceder $1^\circ C$ (Delta T), com um retardo de ativa√ß√£o configur√°vel, para garantir a homogeneiza√ß√£o do mosto. | Alta | Conclu√≠do [üü©üü©üü©üü©üü©] 100% | Entrega 2 | As novas implementa√ß√µes que foram sugeridas move a l√≥gica para o PID, dessa maneira utiliza a l√≥gica via software e n√£o hardware, desabilitando temporariamente a implementa√ß√£o f√≠sica do componente do mixer*. |
| **RF05**  | **Funcional** | O sistema deve exibir continuamente no *display* OLED (ou LCD) a temperatura atual do mosto (obtida pelo sensor principal), o *setpoint* da etapa atual da curva, o tempo restante para a etapa atual e o *status* operacional do *mixer* e resist√™ncias. | Alta          | Conclu√≠do  [üü©üü©üü©üü©üü©] 100% | Entrega 2 | A exibi√ß√£o foi aprimorada para indicar claramente a fase de rampa, mostrando "Aguardando Setpoint..." ou o tempo restante, tornando o feedback ao usu√°rio muito mais completo e preciso em rela√ß√£o ao estado real do processo. |
| **RF06**  | **Funcional**   | O sistema deve emitir alertas visuais (LEDs) ou sonoros (BUZZER) para notificar o usu√°rio sobre erros cr√≠ticos de opera√ß√£o (ex: falha de sensor, sobreaquecimento, erro de comunica√ß√£o), indicando o tipo de falha. | Alta | Conclu√≠da [üü©üü©üü©üü©üü©] 100% | Entrega 3 | Especifica os tipos de alerta e a informa√ß√£o a ser passada (tipo de falha). |
| **RF07**  | **Funcional** | O sistema deve permitir ao usu√°rio selecionar o modo de controle (PID ou ON/OFF) antes ou durante o in√≠cio de uma nova brassagem, atrav√©s da interface de usu√°rio (teclado ou serial). | Alta          | Conclu√≠do [üü©üü©üü©üü©üü©] 100% | Entrega 2 | Na implementa√ß√£o 0.8.0 foi implementado o sistema via histerese ON/OFF por√©m se notou certas inconsist√™ncias no desempenho do projeto, no qual n√£o √© ideal em uma aplica√ß√£o real, neste caso foi substitu√≠do pela vers√£o 0.9.0 na qua implementa um sistema de PID mais robusto e operacional, desse modo esperamos um comportamento mais esperado do ideal e mais profissional. |
| **RF08**  | **Funcional**   | O sistema deve implementar um "Modo de Calibra√ß√£o" para os sensores de temperatura, permitindo ao usu√°rio ajustar *offsets* ou fatores de calibra√ß√£o para leituras mais precisas, com base em temperaturas de refer√™ncia conhecidas. | Baixa | Conclu√≠do [üü©üü©üü©üü©üü©] 100% | Entrega 3 | O sistema permite ajustes por√©m s√£o hard-coded, sendo poss√≠vel ajustar antes de fazer o upload do sistema. |
| **RF09**  | **Funcional**   | O sistema deve permitir ao usu√°rio visualizar os par√¢metros espec√≠ficos da curva de brassagem em tempo real (ex: *setpoint* de temperatura, dura√ß√£o da etapa) atrav√©s da comunica√ß√£o UART, sem interromper o processo atual. | Baixa         | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 2 | O sistema √© capaz de fornecer informa√ß√µes ao usu√°rio via UART e via DisplayOLED, detalhando todos os passos e progresso em tempo real. |
| **RF10**  | **Funcional**   | O sistema deve registrar em mem√≥ria n√£o vol√°til (*Flash* ou EEPROM) os par√¢metros de cada brassagem conclu√≠da (curva utilizada, temperaturas m√°ximas/m√≠nimas atingidas, dura√ß√£o total) e permitir a consulta desses *logs* via UART. | M√©dia         | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 3 | Funcionalidade adicional de hist√≥rico, √∫til para otimiza√ß√£o de receitas. |
| **RF11**  | **Funcional**   | O sistema deve suportar a cria√ß√£o de "receitas", que s√£o sequ√™ncias pr√©-definidas de curvas de brassagem (ex: *Mash*, *Boil*, *Fermenta√ß√£o*), permitindo ao usu√°rio selecionar e executar uma receita completa. | Alta | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 3 | A l√≥gica e o gerenciamento das receitas est√£o integradas no c√≥digo, sendo poss√≠vel adicionar quantas receitas fixas quiser com algumas regras de ne√≥cio envolvidas como limites de curvas por exemplo. |
| **RF12**  | **Funcional**   | O sistema deve fornecer *feedback* visual (ex: √≠cones no *display* ou LEDs de *status*) sobre o estado atual dos atuadores (resist√™ncias ligadas/desligadas, *mixer* ativo/inativo), mesmo quando n√£o houver erro cr√≠tico, para facilitar o monitoramento do processo. | M√©dia | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 2           | Os setups, aquecedores, PWM, i2C, etapas e todos os perif√©ricos existentes foram substitu√≠dos por logs no Serial Monitor, os feedbacks visuais s√£o mostrados na barra quando o sistema √© iniciado e s√£o gerados a cada step do processo. |
| **RNF01** | **N√£o Funcional** | A arquitetura de *software* deve ser port√°vel, permitindo que o sistema seja executado tanto em uma plataforma embarcada (ESP32) quanto em um ambiente de simula√ß√£o no PC, utilizando abstra√ß√£o de *hardware* (HAL) para facilitar a troca de implementa√ß√µes de perif√©ricos. | Alta | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 3           |  A inclus√£o da biblioteca PID e a forma como ela se integra (Setpoint, Input, Output) demonstram que o controle √© desacoplado da origem da temperatura e do destino do PWM. O simulador I2C aprimorado (com modelo de in√©rcia) mesmo com o uso de uma simula√ß√£o feita atrav√©s de um Mestre-Escravo refor√ßa esse requisito. |
| **RNF02** | **N√£o Funcional** | O c√≥digo-fonte deve ser implementado em C++ seguindo princ√≠pios de Orienta√ß√£o a Objetos (OO), com uso extensivo de polimorfismo e m√©todos virtuais, para garantir modularidade, reusabilidade e extensibilidade do sistema. | Alta | Em andamento [üü©üü©üü©üü©üü©] 100%     | Todas | A adi√ß√£o da biblioteca PID como um objeto e a intera√ß√£o com ela refor√ßam ainda mais as boas pr√°ticas de OO e encapsulamento. |
| **RNF03** | **N√£o Funcional** | O projeto deve ser versionado no GitHub com um hist√≥rico de *commits* claro e descritivo, refletindo o progresso incremental e as mudan√ßas significativas em cada funcionalidade implementada. | Alta | Conclu√≠do  [üü©üü©üü©üü©üü©] 100%      | Todas | Todosos commits durante o projeto foram feitos periodicamente e com coment√°rios claros e descritivos para enfatizar a qualidade do versionamento. |
| **RNF04** | **N√£o Funcional** | Toda a base de c√≥digo deve ser documentada utilizando Doxygen, gerando uma documenta√ß√£o t√©cnica completa das fun√ß√µes, classes, vari√°veis e m√≥dulos, facilitando a compreens√£o e manuten√ß√£o por outros desenvolvedores. | Alta | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 3 | Especifica "toda a base de c√≥digo" e o benef√≠cio da documenta√ß√£o. |
| **RNF05** | **N√£o Funcional** | O sistema deve incorporar prote√ß√£o el√©trica robusta contra curtos-circuitos, sobreaquecimento e surtos de tens√£o nos circuitos de controle das resist√™ncias e do *mixer*, garantindo a seguran√ßa do equipamento e do usu√°rio. | Baixa         | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 3           | A ideaia do projeto era ter algo robusto como circuito com fus√≠veis, termistores e testes el√©tricos necess√°rios, por√©m devido o andaento do projeto n√£o foi necess√°rio a implementa√ß√£o de sistemas como esses pois os dispositivos usados s√£o de baixa voltagem. |
| **RNF07** | **N√£o Funcional** | Deve ser fornecido um manual de montagem detalhado, com diagramas de fia√ß√£o, fotos ilustrativas e lista de materiais (BOM), para permitir que um usu√°rio replique o *hardware* do sistema. | M√©dia         | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 3           | Apesar do projeto j√° ser previamente montado para seu transporte e uso. A montagem foi descrita na documenta√ß√£o, com imagens e demonstra√ß√µes em v√≠deo. |
| **RNF08** | **N√£o Funcional** | O sistema deve gerar *logs* de eventos detalhados (ex: mudan√ßas de *setpoint*, ativa√ß√£o/desativa√ß√£o de atuadores, erros de sensor) via UART, que possam ser facilmente consumidos e analisados por uma aplica√ß√£o no PC para depura√ß√£o e monitoramento. | Alta          | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 3           |  Os logs seriais no mestre e escravo s√£o bem descritivos via UART e possuem informa√ß√µes visuais atrav√©s de LEDS e DisplayOLED.  |
| **RNF09** | **N√£o Funcional** | O *software* deve ser projetado com alta coes√£o e baixo acoplamento entre os m√≥dulos, utilizando interfaces bem definidas para facilitar futuras expans√µes e manuten√ß√µes sem impacto em outras partes do sistema. | M√©dia | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 2           |  A adi√ß√£o do PID como uma biblioteca separada que interage com Input/Output globais refor√ßa ainda mais o baixo acoplamento e a modularidade. exigida por esse requisito.  |
| **RNF10** | **N√£o Funcional** | O sistema deve reagir a altera√ß√µes nos sensores ou comandos de controle e atualizar o estado dos atuadores e do *display* em no m√°ximo 500ms, para garantir uma experi√™ncia de usu√°rio responsiva e controle em tempo real. | Baixa         | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 2           | A malha de controle PID √© r√°pida, mas a interface com o usu√°rio poderia passar por um processo melhor de ajustes finos, por√©m est√° funcional. |
| **RNF11** | **N√£o Funcional** | O *software* deve ser submetido a testes unit√°rios automatizados para as camadas de l√≥gica de controle e m√≥dulos cr√≠ticos, utilizando um *framework* de teste (ex: Unity, Google Test) para garantir a robustez e corre√ß√£o do c√≥digo. | Baixa         | Pendente [üü•üü•üü•üü•üü•] 0%      | Entrega 3           | Desenvolver testes usando *frameworks* como Unity ou GoogleTest. |
| **RNF12** | **N√£o Funcional** | O sistema deve permitir o ajuste manual da pot√™ncia de sa√≠da para as resist√™ncias (ex: via PWM), permitindo ao usu√°rio sobrescrever temporariamente o controle autom√°tico em situa√ß√µes espec√≠ficas de *fine-tuning* ou emerg√™ncia. | Baixa         | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 2           | Possui estrutura hard-coded preparada para receber dados facilmente. |
| **RNF13** | **N√£o Funcional** | O sistema deve detectar e alertar sobre a perda de comunica√ß√£o com qualquer sensor I¬≤C (ex: por *timeout* ou falha de CRC), e tentar restabelecer a comunica√ß√£o automaticamente antes de reportar uma falha cr√≠tica. | Baixa         | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 3           | A l√≥gica na simula√ß√£o da temperatura continua a ser a principal detec√ß√£o de falha de comunica√ß√£o I2C. Poderia ter retries ou recupera√ß√£o mais avan√ßada por√©m √© funcional. |
| **RNF14** | **N√£o Funcional** | O sistema deve ser capaz de calibrar automaticamente ou semi-automaticamente os sensores de temperatura durante o processo de brassagem, compensando varia√ß√µes devido √† imers√£o ou tipo de sensor, utilizando pontos de calibra√ß√£o conhecidos. | Alta          | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 2           | O uso do PID controla e calibra automaticamente a temperatura de brasagem. |
| **RNF15** | **N√£o Funcional** | A interface de usu√°rio via teclado deve ser intuitiva e eficiente, permitindo a navega√ß√£o pelos menus e a entrada de dados com um m√≠nimo de passos, para uma boa experi√™ncia do usu√°rio. | M√©dia         | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | As informa√ß√µes do processo no display d√£o clareza para o usu√°rio, com informa√ß√µes claras, tornando a IHM mais eficiente em transmitir o estado do processo. |
| **RNF16** | **N√£o Funcional** | O consumo de energia do sistema deve ser otimizado para opera√ß√£o de longo prazo, especialmente em modos de espera ou monitoramento, para minimizar o aquecimento desnecess√°rio e potencializar o uso de fontes de energia. | Baixa         | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 2           | Foi implementado sistemas de circuit-breaker do sistema, desligando atuadores e perif√©ricos ap√≥s uso das receitas, visando o consumo de energia do sistema. |
| **RNF17** | **N√£o Funcional** | O c√≥digo deve seguir um guia de estilo de codifica√ß√£o (ex: Google Style Guide, MISRA C/C++) para garantir consist√™ncia, legibilidade e manutenibilidade em todo o projeto. | Baixa         | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 3           | C√≥digo escrito em formato clean code em C++ e com bastante detalhamento para documenta√ß√£o. |
| **RNF18** | **N√£o Funcional** | A interface de comunica√ß√£o serial (UART) deve ser baseada em um protocolo bem definido (ex: ASCII com *checksum* ou JSON para comandos/dados), garantindo a robustez e a interoperabilidade com *softwares* externos (PC). | Alta          | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 2           | A interface de comunica√ß√£o √© feita via displayOLED e teclado matricial. |
| **RNF19** | **N√£o Funcional** | O sistema deve ter capacidade de *over-the-air (OTA) update* para o *firmware*, permitindo atualiza√ß√µes de *software* remotas sem a necessidade de conex√£o f√≠sica via USB, facilitando a manuten√ß√£o e a adi√ß√£o de novas funcionalidades p√≥s-implanta√ß√£o. | M√©dia         | Pendente [üü•üü•üü•üü•üü•] 0%      | Entrega 3           | Um requisito de manuten√ß√£o moderna para sistemas embarcados, crucial para a longevidade do produto. |
| **RNF20** | **N√£o Funcional** | O *software* deve ser resiliente a falhas tempor√°rias (ex: ru√≠do el√©trico, pequenas interrup√ß√µes de comunica√ß√£o), implementando mecanismos como *debouncing* para entradas digitais, *timeouts* com *retries* para comunica√ß√µes e inicializa√ß√£o segura dos perif√©ricos. | Alta          | Conclu√≠do [üü©üü©üü©üü©üü©] 100%      | Entrega 2           | O modelo de in√©rcia t√©rmica no simulador escravo torna a simula√ß√£o mais realista e robusta, e a controle lida com valores de temperatura (mesmo que simulados) com mais complexidade. Isso refor√ßa a resili√™ncia do sistema de controle em si. |

### Observa√ß√µes:

#### Progresso Geral

- Requisitos Funcionais: **11/12** ‚úÖ
- Requisitos N√£o Funcionais: **18/20** ‚úÖ

**Total geral: 29/32 requisitos conclu√≠dos** (üîµ ~90%)

---

#### Requisito Funcional - 03: 

* **Descri√ß√£o:**

*O sistema deve permitir o *upload* de curvas de temperatura customizadas via interface serial (UART), ou via comandos em tela (KEYPAD 4X4). Cada curva deve conter m√∫ltiplos *steps* definidos por temperatura e dura√ß√£o, e o sistema deve validar a integridade dos dados recebidos.*

* **Status:**

Durante o desenvolvimento do projeto, um dos requisitos inicialmente propostos precisou ser removido da vers√£o final apresentada. Apesar de sua estrutura conceitual estar devidamente modelada na plataforma Itemis, a implementa√ß√£o pr√°tica no c√≥digo ainda demandava ajustes significativos para garantir um funcionamento est√°vel e conforme os padr√µes de qualidade exigidos.

Em fun√ß√£o do tempo dispon√≠vel para entrega e da complexidade envolvida na corre√ß√£o de determinados bugs, optou-se por desativar temporariamente essa funcionalidade. Essa decis√£o foi tomada com o intuito de priorizar a entrega de um sistema funcional, est√°vel e coerente com os demais requisitos implementados, evitando que poss√≠veis inconsist√™ncias t√©cnicas impactassem negativamente na experi√™ncia de uso ou na avalia√ß√£o do projeto.

A funcionalidade removida permanece documentada e estruturada de forma modular, o que possibilita sua futura reintegra√ß√£o ao sistema com as devidas corre√ß√µes e valida√ß√µes. Essa abordagem evidencia a preocupa√ß√£o com a qualidade do c√≥digo e com a viabilidade t√©cnica do projeto, demonstrando uma postura respons√°vel diante das limita√ß√µes de tempo e recursos enfrentadas na reta final do desenvolvimento.

* **Planejamento Futuro:**

Esta funcionalidade permanece documentada e com estrutura modular, permitindo que seja reintegrada em futuras vers√µes do sistema com as devidas corre√ß√µes e valida√ß√µes.

#### Requisito N√£o Funcional - 11:

* **Descri√ß√£o:**

O *software* deve ser submetido a testes unit√°rios automatizados para as camadas de l√≥gica de controle e m√≥dulos cr√≠ticos, utilizando um *framework* de teste (ex: Unity, Google Test) para garantir a robustez e corre√ß√£o do c√≥digo.

* **Status:**

Durante a fase final de desenvolvimento, foi priorizado a estabiliza√ß√£o das funcionalidades principais e a integra√ß√£o dos m√≥dulos em tempo real, o que exigiu esfor√ßos intensivos de depura√ß√£o e testes manuais. Com isso, a implementa√ß√£o de testes unit√°rios automatizados, embora considerada uma boa pr√°tica de engenharia de software, acabou sendo adiada devido √† limita√ß√£o de tempo e √† necessidade de ajustes constantes no c√≥digo base.

Al√©m disso, a configura√ß√£o adequada do ambiente de testes com frameworks como Unity ou Google Test requer um tempo inicial de estrutura√ß√£o e integra√ß√£o que n√£o p√¥de ser absorvido sem comprometer o cronograma das demais entregas.

* **Planejamento Futuro:**

A inclus√£o de testes automatizados continua sendo uma etapa planejada para vers√µes futuras do projeto por√©m segue com **prioridade baixa**. Com a estabiliza√ß√£o da base de c√≥digo, ser√° poss√≠vel estruturar um ambiente de testes e implementar uma su√≠te de testes unit√°rios abrangente, aumentando a confiabilidade e facilitando futuras manuten√ß√µes.

#### Requisito N√£o Funcional - 19:

* **Descri√ß√£o:**

O sistema deve ter capacidade de *over-the-air (OTA) update* para o *firmware*, permitindo atualiza√ß√µes de *software* remotas sem a necessidade de conex√£o f√≠sica via USB, facilitando a manuten√ß√£o e a adi√ß√£o de novas funcionalidades p√≥s-implanta√ß√£o.

* **Status:**

A implementa√ß√£o do mecanismo de atualiza√ß√£o OTA exige uma arquitetura de firmware mais robusta, com particionamento de mem√≥ria apropriado (dual bank ou bootloader dedicado), al√©m de um gerenciamento seguro de pacotes de atualiza√ß√£o e verifica√ß√£o de integridade. Durante a fase de desenvolvimento, constatou-se que a plataforma de hardware utilizada apresentava limita√ß√µes de mem√≥ria e conectividade que comprometeriam a implementa√ß√£o segura e confi√°vel desse recurso.

Al√©m disso, o desenvolvimento de um sistema OTA funcional implicaria em um aumento consider√°vel na complexidade do projeto, demandando integra√ß√£o com protocolos de rede, criptografia e fallback seguro em caso de falha durante a atualiza√ß√£o ‚Äî etapas que exigiriam tempo e testes adicionais fora do escopo da entrega atual.

Diante dessas limita√ß√µes t√©cnicas e do foco na entrega de um sistema funcional e test√°vel localmente, optou-se por adiar esse requisito para vers√µes futuras.

* **Planejamento Futuro:**

Para o projeto viu-se com o andamento que a funcionalidade de OTA foi completamente descartada para vers√µes futuras do sistema, especialmente em contextos de implanta√ß√£o real.

---

### Funcionalidades Extras
Nesta etapa do projeto, foram incorporadas funcionalidades adicionais que, embora n√£o estejam entre os requisitos principais, enriquecem a usabilidade e o controle do sistema.

##### Teclado Matricial 4x4:
Permite ao usu√°rio navegar por menus, selecionar receitas, iniciar ou abortar processos e ajustar configura√ß√µes diretamente no sistema, sem necessidade de interface externa. A intera√ß√£o torna o sistema aut√¥nomo e mais acess√≠vel.

##### Sem√°foro Indicador (RYG):
M√≥dulo visual com LEDs nas cores vermelho, amarelo e verde que indicam, de forma intuitiva, o estado atual da brassagem:

üî¥ **Vermelho:** Erros ou sa√≠da do sistema.<br>
üü° **Amarelo:** Aquecimento ou rampa de temperatura.<br>
üü¢ **Verde:** Pronto para inicializar as receitas.

##### Visualiza√ß√£o Gr√°fica da Curva de Temperatura:
Possibilidade futura de integrar o sistema com uma interface gr√°fica no PC, permitindo ao usu√°rio visualizar em tempo real o progresso da curva de temperatura e eventos do processo.

##### Registro e Exporta√ß√£o de Logs:
Registro das sess√µes de brassagem em mem√≥ria e envio via UART, permitindo an√°lise posterior do desempenho t√©rmico e hist√≥rico das receitas utilizadas

---

### Receitas Utilizadas
Aqui √© relacionado as receitas que foram escolhidas para serem implementadas no projeto, desde b√°sicas at√© mais elaboradas.
| Receita | Etapa| Temperatura (¬∞C) | Tempo (min) | Observa√ß√µes| Refer√™ncia |
|:----:|:----:|:----:|:----:|:----:|:----:|
| **American Pale Ale** | Mostura (Infus√£o) | 67 | 60 | Convers√£o de amido em a√ß√∫cares ferment√°veis via enzimas | thebeerjunkies.com/pale-ale/ |
| | Mash Out (Aquecimento Final) | 76 | 10 | Inativa√ß√£o enzim√°tica, reduz viscosidade e facilita a lavagem dos gr√£os | |
| **Witbier** | Descanso de Prote√≠na | 50 | 15 | Quebra de prote√≠nas grandes, melhora corpo, espuma e clareamento | ultralowbrewing.com/wp-content/uploads/2022/01/guide-to-step-mashing.pdf |
| | Descanso de Sacarifica√ß√£o | 68 | 60 | Convers√£o de amido em a√ß√∫cares ferment√°veis e n√£o ferment√°veis, ajusta final da cerveja | |
| | Mash Out | 76 | 10 | Inativa√ß√£o enzim√°tica e preparo para lavagem | |
| **Belgian Dubbel** | Descanso de Prote√≠na | 52 | 15 | Quebra de prote√≠nas para corpo, estabilidade de espuma e nutrientes de levedura | byo.com/article/belgian-dubbel/ | |
| | Sacarifica√ß√£o Baixa | 64 | 45 | Gera mais maltose ferment√°vel para um final seco | |
| | Sacarifica√ß√£o Alta | 72 | 15 | Produz dextrinas para corpo e dul√ßor | |
| | Mash Out | 76 | 10 | Encerra a mostura e inativa enzimas | |
| **Bohemian Pilsen** | Descanso de Acidez/Fer√∫lico | 45 | 15 | Ajusta pH, ajuda a criar notas de cravo (em trigo) e melhora a sensa√ß√£o da boca | forum.northernbrewer.com/t/converting-a-step-mash-recipe-into-a-single-infusion-mash/4630 |
| | Descanso de Prote√≠na | 52 | 15 | Melhora claridade e estabilidade da espuma | |
| | Beta-Amilase | 63 | 45 | M√°xima produ√ß√£o de maltose, final seco | |
| | Alpha-Amilase | 72 | 15 | Produ√ß√£o de dextrinas, aumenta corpo e sensa√ß√£o de boca | |
| | Mash Out | 76 | 10 | Inativa√ß√£o enzim√°tica e prepara√ß√£o para lavagem | |
| **Customizada** | N | N | N | N | A receita customizada dever√° ser informada pelo usu√°rio na tela de receitas, ele pode criar as etapas conforme prefer√™ncia |

---

### Resultados e Logs de Processo
Durante a execu√ß√£o de uma receita, o sistema registra uma s√©rie de eventos via UART, que incluem:

- Aquisi√ß√µes de temperatura
- Atingimento de setpoint
- Ativa√ß√£o/desativa√ß√£o dos atuadores
- Tempo restante de cada etapa
- Alertas ou falhas detectadas

Incluindo o registro em segundos da temperatura durante as etapas de brasagem, nas quais no final de cada processo podemos obter com o bot√£o ```*``` na etapa ```IDLE``` os logs entre ```Tempo X Temperatura``` e assim usar para construir um gr√°fico.

Como um exemplo pr√°tico podemos pegar o *output* da **Receita: APA**.

- Durante a etapa de brasagem da Receita 1 foi gerado esses valores para as Curvas 1 e 2.
```d
TempoSeg;TempAtual;SaidaPWM;Curva
11;25.11;1023;1
12;25.10;1023;1
...
...
...
179;77.21;548;2
180;77.18;543;2
182;77.13;539;2
```
*Os tempos de cada curva foram reduzidos para 1 minuto para fins de testes*

Usado o script que se encontra em ```../freeRTOS/borracho/log_analysis/log_analysis.py```

Podemos gerar o gr√°fico e ver como o controle PID atua em rela√ß√£o a oscila√ß√£o e comose comporta na estabiliza√ß√£o durante a Curva 1 e a Curva 2.

![Gr√°fico do Controle PID](media/log_graph.png)

Al√©m disso podemos obter alguns dados essenciais, como:

```text
* M√©tricas da Curva 1 (Setpoint = 67¬∞C):
Overshoot: 9.50 ¬∞C
Tempo de subida: 13.00 s
Tempo de estabiliza√ß√£o: 43.00 s
Erro m√©dio absoluto: 4.85 ¬∞C

* M√©tricas da Curva 2 (Setpoint = 76¬∞C):
Overshoot: 1.32 ¬∞C
Tempo de subida: 21.00 s
Tempo de estabiliza√ß√£o: 123.00 s
Erro m√©dio absoluto: 2.30 ¬∞C
```

Vendo essas sa√≠das,podemos ver que o projeto trabalha como proposto e a uma margem bem aceit√°vel de aplica√ß√µes mais profissionais.

---

### Considera√ß√µes Finais e Melhorias Futuras

O projeto apresentado demonstrou a viabilidade de construir um sistema embarcado robusto para controle de temperatura no processo de brassagem artesanal, com foco em modularidade, usabilidade e precis√£o.

Entre os pontos fortes destacam-se:

- Integra√ß√£o funcional entre modelagem e implementa√ß√£o (itemis CREATE ‚Üí C++)
- Controle PID com desempenho comprovado em testes reais e simulados
- Interface intuitiva com teclado e display
- Arquitetura escal√°vel e bem documentada

**Melhorias Futuras Planejadas:**

- Reativar o sistema de upload de curvas customizadas via UART
- Implementar testes automatizados com Google Test
- Explorar atualiza√ß√£o OTA com particionamento de firmware
- Adicionar interface gr√°fica para acompanhamento via PC
- Estender o projeto para controle de fermenta√ß√£o e dry-hopping

Esse projeto abre caminho para futuras automa√ß√µes no universo da produ√ß√£o artesanal de cerveja, com base em princ√≠pios s√≥lidos de engenharia embarcada.

---

### Changelog

Este *changelog* registra as principais vers√µes e funcionalidades implementadas no projeto.

* **v0.1.0** - **In√≠cio do Projeto**
    * Configura√ß√£o inicial do ambiente de desenvolvimento.
    * Cria√ß√£o do reposit√≥rio, requisitos e documenta√ß√£o b√°sica.

* **v0.2.0** - **Valida√ß√£o de Hardware B√°sico**
    * Implementa√ß√£o de uma prova de conceito de "blink" com ESP32 e LED.

* **v0.3.0** - **Funda√ß√£o do Software**
    * Estrutura de software com FreeRTOS e tarefas.
    * Integra√ß√£o inicial com m√°quina de estados (itemis CREATE) e comunica√ß√£o serial.

* **v0.4.0** - **Interface Visual (OLED)**
    * Adi√ß√£o do driver e interface do display OLED (I2C).
    * Visualiza√ß√£o de estados e mensagens no display.

* **v0.5.0** - **Interface de Entrada (Teclado)**
    * Integra√ß√£o do driver para teclado matricial 4x4.
    * Funcionalidade de navega√ß√£o nos menus principais (`IDLE`, `MENU`).

* **v0.6.0** - **Simula√ß√£o de Processo**
    * Estrutura de dados para receitas e etapas em mem√≥ria.
    * Implementa√ß√£o da l√≥gica de gerenciamento de etapas com simula√ß√£o de temperatura e tempo.
    * Navega√ß√£o completa para sele√ß√£o e in√≠cio de receitas pr√©-definidas.
    * Integra√ß√£o e controle do M√≥dulo Sem√°foro LED.

* **v0.7.0** - **Primeira Medi√ß√£o de Hardware**
    * Integra√ß√£o de sensores de temperatura DS18B20 via One-Wire para leituras reais.
    * Substitui√ß√£o da simula√ß√£o de temperatura por dados reais na l√≥gica de controle e display.
    * Aprimoramento do display com temperatura real e *countdown* formatado.
    * Implementa√ß√£o inicial de detec√ß√£o de falha de sensor.

* **v0.8.0** - **Controle B√°sico e Ambiente de Testes**
    * Migra√ß√£o para um simulador de temperatura I2C (mestre-escravo ESP32) para testes mais robustos.
    * Implementa√ß√£o de controle ON/OFF com histerese usando PWM real.
    * Configura√ß√£o do ESP32 escravo com filtro RC para simular in√©rcia t√©rmica.
    * Detec√ß√£o aprimorada de falhas de comunica√ß√£o I2C.

* **v0.9.0** - **Controle Avan√ßado de Temperatura**
    * Substitui√ß√£o do controle ON/OFF por um **controlador PID** utilizando a biblioteca `PID_v1`.
    * Gerenciamento de tempo de etapa condicional (contagem regressiva s√≥ inicia ap√≥s o *setpoint* ser atingido).
    * Refinamento do modelo de in√©rcia t√©rmica no simulador escravo para validar o desempenho do PID.
    * Melhoria na desativa√ß√£o segura do aquecedor ao finalizar ou abortar o processo.
* **v1.0.0** - **Lan√ßamento Oficial**
    * **Sistema Funcional Completo:** Todas as funcionalidades de controle (PID), interface de usu√°rio (teclado, display, sem√°foro) e gerenciamento de receitas est√£o implementadas, testadas e operacionais.
    * **Integra√ß√£o de Atuadores:** Implementa√ß√£o e controle do mixer com l√≥gica de ativa√ß√£o por Delta T.
    * **Robustez e Seguran√ßa:** Mecanismos de detec√ß√£o de falhas e alertas visuais/sonoros est√£o integrados.
    * **Documenta√ß√£o Completa:** Documenta√ß√£o do c√≥digo (Doxygen), manual de montagem e guia do usu√°rio est√£o finalizados.
* **v1.1.0** - **Adi√ß√£o de Funcionalidade de Logging**
    * Implementa√ß√£o da **gera√ß√£o de logs de eventos em formato CSV**.
    * Os logs registram par√¢metros de cada brassagem conclu√≠da, incluindo a curva utilizada, temperaturas e dura√ß√£o total.
    * Os dados podem ser consultados via comunica√ß√£o serial (UART) para an√°lise posterior.
